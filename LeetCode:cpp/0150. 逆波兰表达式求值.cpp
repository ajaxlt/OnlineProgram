#include <iostream>
#include <stack>
#include <string>
#include <vector>
using namespace std;
/*
 * 来源: LeetCode
 * 题目: 逆波兰表达式求值(Evaluate Reverse Polish Notation)
 *
 * 描述:
 * 根据逆波兰表示法，求表达式的值。
 * 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式
 *
 * 说明:
 * 整数除法只保留整数部分
 * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况
 *
 * 示例 1:
 * 输入: ["2", "1", "+", "3", "*"]
 * 输出: 9
 * 解释: ((2 + 1) * 3) = 9
 *
 * 示例 2:
 * 输入: ["4", "13", "5", "/", "+"]
 * 输出: 6
 * 解释: (4 + (13 / 5)) = 6
 *
 * 示例 3:
 * 输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
 * 输出: 22
 *
 * 解释:
 * ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
 * = ((10 * (6 / (12 * -11))) + 17) + 5
 * = ((10 * (6 / -132)) + 17) + 5
 * = ((10 * 0) + 17) + 5
 * = (0 + 17) + 5
 * = 17 + 5
 * = 22
 *
 * 思路:
 * 利用栈
 *
 * 1. 波兰表达式(前缀表达式)
 * 由树的前序遍历结果得到，计算方法:
 * 从右往左扫描，如果遇到数字，推入栈中；如果遇到操作符，从栈中取出两个数字进行运算，并且将运算结果再次推入栈中(二出一进)
 *
 * 2. 逆波兰表达式(后缀表达式)
 * 由树的后序遍历结果得到，计算方法从左往右扫描即可
 */

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        for (string s : tokens) {
            if (s == "+" || s == "-" || s == "*" || s == "/") {
                int b = stk.top();
                stk.pop();
                int a = stk.top();
                stk.pop();
                if (s == "+") stk.push(a + b);
                else if (s == "-") stk.push(a - b);
                else if (s == "*") stk.push(a * b);
                else stk.push(a / b);
            } else stk.push(atoi(s.c_str()));
        }
        return stk.top();
    }
};
